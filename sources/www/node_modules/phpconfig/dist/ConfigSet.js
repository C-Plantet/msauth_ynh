"use strict";
/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
var hasOwn = {}.hasOwnProperty;
/**
 * @inheritDoc
 */
var ConfigSet = /** @class */ (function () {
    function ConfigSet(configs) {
        this.configs = configs;
    }
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.concatArrays = function (settingName) {
        var concatenatedArray = [];
        for (var _i = 0, _a = this.configs; _i < _a.length; _i++) {
            var _b = settingName, rawSettingValue = _a[_i][_b];
            var settingValue = rawSettingValue !== null && rawSettingValue !== void 0 ? rawSettingValue : [];
            if (!Array.isArray(settingValue)) {
                throw new Error("Invalid value for setting " + settingName + ": all values must be arrays but " + typeof settingValue + " (" + settingValue + ") given");
            }
            concatenatedArray.push.apply(concatenatedArray, settingValue);
        }
        return concatenatedArray;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.getBoolean = function (settingName, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        // TODO: Optimise by only extracting values for this specific setting from each config.
        //       For now this is assumed to be efficient enough (as deep and complex config trees
        //       are unlikely)
        var mergedSettingValues = this.mergeAll();
        if (!hasOwn.call(mergedSettingValues, settingName)) {
            // Setting has no value specified in any config
            return defaultValue;
        }
        var settingValue = mergedSettingValues[settingName];
        if (typeof settingValue !== 'boolean') {
            throw new Error("Expected value for setting \"" + settingName + "\" to be a boolean but it was a " + typeof settingValue);
        }
        return settingValue;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.mergeAll = function () {
        var mergedConfig = {};
        var doMerge = function (config) {
            var _a;
            var _b;
            for (var _i = 0, _c = Object.keys(config); _i < _c.length; _i++) {
                var settingName = _c[_i];
                var settingValue = config[settingName];
                if (settingValue === null || typeof settingValue !== 'object') {
                    // Latest setting is not a non-null object: this one should replace any value completely
                    mergedConfig[settingName] = settingValue;
                    continue;
                }
                if (Array.isArray(settingValue)) {
                    // Latest setting value is an array
                    if (Array.isArray(mergedConfig[settingName])) {
                        // Setting in work area is also an array: just concatenate onto the end
                        (_a = mergedConfig[settingName]).push.apply(_a, settingValue);
                    }
                    else {
                        // Setting in work area is not an array: this one should replace the value completely
                        mergedConfig[settingName] = settingValue;
                    }
                }
                else {
                    // Latest setting is an object: merge it onto the existing one (if any)
                    Object.assign((_b = mergedConfig[settingName]) !== null && _b !== void 0 ? _b : (mergedConfig[settingName] = {}), settingValue);
                }
            }
        };
        for (var _i = 0, _a = this.configs; _i < _a.length; _i++) {
            var config = _a[_i];
            doMerge(config);
        }
        return mergedConfig;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.mergeObjects = function (settingName) {
        var mergedConfig = {};
        for (var _i = 0, _a = this.configs; _i < _a.length; _i++) {
            var _b = settingName, rawSettingValue = _a[_i][_b];
            var settingValue = rawSettingValue !== null && rawSettingValue !== void 0 ? rawSettingValue : {};
            if (typeof settingValue !== 'object') {
                throw new Error("Invalid value for setting " + settingName + ": all values must be objects but " + typeof settingValue + " (" + settingValue + ") given");
            }
            Object.assign(mergedConfig, settingValue);
        }
        return mergedConfig;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.mergeUniqueObjects = function (settingName) {
        var _a;
        var mergedConfig = {};
        for (var _i = 0, _b = this.configs; _i < _b.length; _i++) {
            var config = _b[_i];
            var settingValue = void 0;
            if (settingName) {
                // A setting was specified: merge all values for that setting
                var rawSettingValue = config[settingName];
                settingValue = (_a = rawSettingValue) !== null && _a !== void 0 ? _a : {};
                if (typeof settingValue !== 'object') {
                    throw new Error("Invalid value for setting " + settingName + ": all values must be objects but " + typeof settingValue + " (" + settingValue + ") given");
                }
            }
            else {
                // No setting was specified: merge the configs themselves
                settingValue = config;
            }
            for (var _c = 0, _d = Object.keys(settingValue); _c < _d.length; _c++) {
                var propertyName = _d[_c];
                if (hasOwn.call(mergedConfig, propertyName) &&
                    // Allow a setting to be overridden with the exact same value
                    // (eg. where multiple plugins are used that define the same flag setting)
                    mergedConfig[propertyName] !== settingValue[propertyName]) {
                    var newValue = settingValue[propertyName];
                    var propertyOrSettingName = settingName !== null && settingName !== void 0 ? settingName : propertyName;
                    var propertyOrSetting = settingName
                        ? "property \"" + propertyName + "\""
                        : 'setting';
                    throw new Error("Invalid value for setting " + propertyOrSettingName + ": all objects must be unique but " + propertyOrSetting + " has both value (" + mergedConfig[propertyName] + ") and value (" + newValue + ")");
                }
            }
            Object.assign(mergedConfig, settingValue);
        }
        return mergedConfig;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.toArray = function () {
        return this.configs;
    };
    return ConfigSet;
}());
exports.default = ConfigSet;
//# sourceMappingURL=ConfigSet.js.map